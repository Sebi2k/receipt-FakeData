import sqlalchemy
import os
import dotenv
from faker import Faker
import numpy as np

def database_connection_url():
    dotenv.load_dotenv()
    DB_USER: str = os.environ.get("POSTGRES_USER")
    DB_PASSWD = os.environ.get("POSTGRES_PASSWORD")
    DB_SERVER: str = os.environ.get("POSTGRES_SERVER")
    DB_PORT: str = os.environ.get("POSTGRES_PORT")
    DB_NAME: str = os.environ.get("POSTGRES_DB")
    return f"postgresql://{DB_USER}:{DB_PASSWD}@{DB_SERVER}:{DB_PORT}/{DB_NAME}"

# Create a new DB engine based on our connection string
engine = sqlalchemy.create_engine(database_connection_url(), use_insertmanyvalues=True)

with engine.begin() as conn:
    conn.execute(sqlalchemy.text("""
    DROP TABLE IF EXISTS receipts;
    DROP TABLE IF EXISTS purchases;
    DROP TABLE IF EXISTS transactions;
    DROP TABLE IF EXISTS users;

    CREATE TABLE 
        public.users (
            id bigint generated by default as identity,
            name text not null,
            email text not null,
            constraint Users_pkey primary key (id),
            constraint users_email_check check (
                (
                    email ~* '^[A-Za-z0-9._+%-]+@[A-Za-z0-9.-]+[.][A-Za-z]+$'::text
                )
            )
        ) tablespace pg_default;

    CREATE TABLE 
        public.transactions (
            id bigint generated by default as identity,
            user_id bigint not null,
            merchant text not null,
            description text null,
            created_at timestamp with time zone not null default now(),
            date text null,
            constraint Transaction_pkey primary key (id),
            constraint transactions_user_id_fkey foreign key (user_id) references users (id) on update cascade on delete cascade
        ) tablespace pg_default;

    CREATE TABLE 
        public.purchases (
            id bigint generated by default as identity,
            transaction_id bigint not null,
            item text not null,
            price integer not null,
            warranty_date text null,
            return_date text null,
            category text not null default 'Other'::text,
            quantity integer not null default 1,
            constraint Purchase_pkey primary key (id),
            constraint purchases_transaction_id_fkey foreign key (transaction_id) references transactions (id) on update cascade on delete cascade,
            constraint purchases_category_check check (
                (
                    category = any (
                        array[
                            'Groceries'::text,
                            'Clothing and Accessories'::text,
                            'Electronics'::text,
                            'Home and Garden'::text,
                            'Health and Beauty'::text,
                            'Entertainment'::text,
                            'Travel'::text,
                            'Automotive'::text,
                            'Services'::text,
                            'Gifts and Special Occasions'::text,
                            'Education'::text,
                            'Fitness and Sports'::text,
                            'Pets'::text,
                            'Office Supplies'::text,
                            'Financial Services'::text,
                            'Other'::text
                        ]
                    )
                )
            ),
            constraint purchases_price_check check ((price >= 0)),
            constraint purchases_quantity_check check ((quantity >= 1))
        ) tablespace pg_default;

    CREATE TABLE 
        public.receipts (
            id bigint generated by default as identity,
            transaction_id bigint null,
            url text not null,
            parsed_data text not null,
            constraint Reciept_pkey primary key (id),
            constraint receipts_transaction_id_fkey foreign key (transaction_id) references transactions (id) on update cascade on delete cascade
        ) tablespace pg_default;
    """))

# use about 63,000 users for aprox 1,000,000 rows data total
num_users = 63000
fake = Faker()

# create fake users
with engine.begin() as conn:
    print("creating fake users...")
    for i in range(num_users):
        if (i % 10 == 0):
            print(i)

        user_id = conn.execute(sqlalchemy.text("""
        INSERT INTO public.users (name, email) VALUES (:name, :email) RETURNING id;
        """), {"name": fake.name(), "email": fake.email()}).scalar_one()

        # create fake transactions
        num_transactions = np.random.randint(1, 5)
        for j in range(num_transactions):
            merchant = fake.company()
            description = fake.sentence()
            date = fake.date_time_between(start_date='-1y', end_date='now', tzinfo=None)
            
            transaction_id = conn.execute(sqlalchemy.text("""
            INSERT INTO public.transactions (user_id, merchant, description, created_at, date) 
            VALUES (:user_id, :merchant, :description, :created_at, :date) RETURNING id;
            """), {"user_id": user_id, "merchant": merchant, "description": description, "created_at": date, "date": date}).scalar_one()

            # create fake purchases
            num_purchases = np.random.randint(1, 5)
            for k in range(num_purchases):
                item = fake.word()
                price = np.random.randint(1, 100)
                warranty_date = fake.date_between(start_date='now', end_date='+1y').strftime("%Y-%m-%d")
                return_date = fake.date_between(start_date='+1d', end_date='+1y').strftime("%Y-%m-%d")
                category = fake.random_element(elements=['Groceries', 'Clothing and Accessories', 'Electronics', 'Home and Garden', 
                                                        'Health and Beauty', 'Entertainment', 'Travel', 'Automotive', 
                                                        'Services', 'Gifts and Special Occasions', 'Education', 
                                                        'Fitness and Sports', 'Pets', 'Office Supplies', 
                                                        'Financial Services', 'Other'])
                quantity = np.random.randint(1, 10)

                purchase_id = conn.execute(sqlalchemy.text("""
                INSERT INTO public.purchases (transaction_id, item, price, warranty_date, return_date, category, quantity) 
                VALUES (:transaction_id, :item, :price, :warranty_date, :return_date, :category, :quantity) RETURNING id;
                """), {"transaction_id": transaction_id, "item": item, "price": price, 
                       "warranty_date": warranty_date, "return_date": return_date, 
                       "category": category, "quantity": quantity}).scalar_one()

                # create fake receipts
                url = fake.uri()
                parsed_data = fake.text()
                conn.execute(sqlalchemy.text("""
                INSERT INTO public.receipts (transaction_id, url, parsed_data) 
                VALUES (:transaction_id, :url, :parsed_data);
                """), {"transaction_id": transaction_id, "url": url, "parsed_data": parsed_data})

print("Fake data generation completed.")
